#!/bin/sh -e

# shellcheck disable=SC3024
# shellcheck disable=SC3030
# shellcheck disable=SC1078                                                  #
set_usage() {
  USAGE="""Usage: ${CMD:=${0##*/}} ${1:-"[bootstrap|up|down|build|help]"} [APPS...|(-a|--all)] [(-v|--verbose)] [(-h|--help)]
  APPS:
    The apps to run this command on.
    
  Options:
    -a|--all - apply to all apps
    -v|--verbose - output additional info to stderr
    -h|--help - display this help text
    ${2}"""
}; set_usage;
set_help() {
  HELP="""Sandcastles - ${1:-"federation sandbox"}
  
  ${2:-"""Easily and quickly set up a federation sandbox, for testing against
  production-like configurations of multiple fediverse backends."""}
  """
}; set_help;
exit2 () { printf >&2 "%s:  %s: '%s'\n%s\n" "$CMD" "$1" "$2" "$USAGE"; exit 2; }
exit_runtime () { 
  printf >&2 "Sandcastles require a container runtime\nYou must install either podman (and podman-compose) or docker"; 
  exit 3;
}
exit_usage() { printf "%s\n" "$USAGE"; exit 0; }
exit_help() { printf "%s\n%s\n" "$HELP" "$USAGE"; exit 0; }
check () { { [ "$1" != "$EOL" ] && [ "$1" != '--' ]; } || exit2 "missing argument" "$2"; }  # avoid infinite loop
verbose () {
  if [ "$opt_verbose" = "true" ]; then
    printf "%s: %s" "$1" "$2" >&2
  fi
}

# parse action
case "$1" in
  # handle help cases
  -h | --help | help ) exit_help;;
  '' ) exit_usage;;
  bootstrap ) opt_action=$1; shift
    set_help "$opt_action" "perform first time setup"
    set_usage "$opt_action"
    ;; 
  up ) opt_action=$1; shift
    set_help "$opt_action" "run the selected apps"
    set_usage "$opt_action"
    ;;
  down ) opt_action=$1; shift
    set_help "$opt_action" "shut down the selected apps"
    set_usage "$opt_action"
    ;;
  build ) opt_action=$1; shift
    set_help "$opt_action" "Build container images with trust for your Sandcastle private CA"
    set_usage "$opt_action" "-r|--required - build required container images not associated with an individual app"
    ;;
  * ) exit2 "invalid command" "$opt_action";;
esac

# parse remaining command-line options
set -- "$@" "${EOL:=$(printf '\1\3\3\7')}"  # end-of-list marker
opt_apps=()
while [ "$1" != "$EOL" ]; do
  opt="$1"; shift
  case "$opt" in

    # defined options - EDIT HERE!
    -a | --all      ) opt_all=true;;
    -h | --help     ) exit_help;;
    -r | --required ) opt_required=true;;

    # process special cases
    --) while [ "$1" != "$EOL" ]; do set -- "$@" "$1"; shift; done;;   # parse remaining as passthrough
    --[!=]*=*) set -- "${opt%%=*}" "${opt#*=}" "$@";;                  # "--opt=arg"  ->  "--opt" "arg"
    -[A-Za-z0-9] | -*[!A-Za-z0-9]*) exit2 "invalid option" "$opt";;    # anything invalid like '-*'
    -?*) other="${opt#-?}"; set -- "${opt%$other}" "-${other}" "$@";;  # "-abc"  ->  "-a" "-bc"
    *) opt_apps+=("$opt");;                                            # positional, rotate to the end
  esac
done; shift

if (command -v podman >/dev/null 2>&1) && (command -v podman-compose >/dev/null 2>&1);  then
  env_runtime="podman"
elif command -v docker >/dev/null 2>&1;  then
  env_runtime="docker"
else
  exit_runtime
fi

verbose "parse options" """DIR = '$DIR'
action = '$opt_action'
@ = ($*)
apps = ${opt_apps[*]}
--all = '$opt_all'
--required = '$opt_required'
--verbose = '$opt_verbose'
runtime = '$env_runtime'
"""

# Zhu Li, do the thing!
case $opt_action in
  up )
    compose_files=("-f" "$DIR/docker-compose.yml")
    if [ "$opt_all" = "true" ]; then
      all_files=$(find "$DIR" -type f -name "*.compose.yml")
      for n in ${all_files[*]}; do compose_files+=("-f" "$n"); done 
    else
      for n in ${opt_apps[*]}; do compose_files+=("-f" "$n.compose.yml"); done
    fi
    cmd_args=("$env_runtime" "compose" "${compose_files[@]}" "up" "-d")
    verbose "up" "${cmd_args[@]}" 
    exec "${cmd_args[@]}"
  ;;

  build )
    docker_files=()
    if [ "$opt_all" = "true" ]; then
      docker_files+=$(find "$DIR" -type f -name "*.Dockerfile")
    elif [ "$opt_required" = "true" ]; then
      docker_files+=("$DIR/proxy.Dockerfile")
    fi
    if [ "$opt_all" != "true" ]; then
      for n in ${opt_apps[*]}; do
        docker_files+=("$(find "$DIR" -type f -name "$n*.Dockerfile")")
      done
    fi
    verbose "build docker files" "${cmd_args[@]}" 
    
#    tags() is an array of "tuples" which don't exist in sh scripts as far as I know.
#    so, it's actually a regular array, but with paired elements.
#    Like ("x.Dockerfile" "tag/x:latest" "y.Dockerfile" "tag/y:latest")...
    tags=()
    for n in ${docker_files[*]}; do
      tags+=("$n" "localhost/sandcastles/$(basename ${n//.Dockerfile})");
    done
    
    i=0
    while [ "$i" -lt ${#tags[@]} ]; do 
      cmd_args=("$env_runtime" "build" "$DIR" "-f" "${tags[i]}" "-t" "${tags[i+1]}:latest")
      if [ $env_runtime = "podman" ]; then
        cmd_args+=("--format" "docker")
      fi
      verbose "build command" "${cmd_args[@]}" 
      "${cmd_args[@]}"
      i=$((i+2))
    done
  ;;
esac
