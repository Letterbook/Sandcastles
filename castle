#!/bin/sh -e

# shellcheck disable=SC3024
# shellcheck disable=SC3030
# shellcheck disable=SC1078                                                  #
DIR=$(dirname "$(readlink -f -- "$0")")
C_GREEN="\033[0;32m"
C_BLUE="\033[0;34m"
C_NONE="\033[0m"
set_usage() {
  USAGE="""Usage: ${CMD:=${0##*/}} ${1:-"[bootstrap|up|down|build|help]"} [APPS...|(-a|--all)] [(-v|--verbose)] [(-d|--dry-run)] [(-h|--help)]
  APPS:
    The apps to run this command on.
    
  Options:
    -a|--all - apply to all apps
    -v|--verbose - output additional info to stderr
    -d|--dry-run - preview the commends to be run, but do not execute them
    -h|--help - display this help text
    ${2}"""
}; set_usage;
set_help() {
  HELP="""Sandcastles - ${1:-"federation sandbox"}
  
  ${2:-"""Easily and quickly set up a federation sandbox, for testing against
  production-like configurations of multiple fediverse backends."""}
  """
}; set_help;
exit2 () { printf >&2 "%s:  %s: '%s'\n%s\n" "$CMD" "$1" "$2" "$USAGE"; exit 2; }
exit_runtime () { 
  printf >&2 "Sandcastles require a container runtime\nYou must install either podman (and podman-compose) or docker"; 
  exit 3;
}
exit_usage() { printf "%s\n" "$USAGE"; exit 0; }
exit_help() { printf "%s\n%s\n" "$HELP" "$USAGE"; exit 0; }
check () { { [ "$1" != "$EOL" ] && [ "$1" != '--' ]; } || exit2 "missing argument" "$2"; }  # avoid infinite loop
verbose () {
  if [ "$opt_verbose" = "true" ]; then
    debug=$1; shift
    printf "${C_GREEN}%s${C_NONE}\n%s\n" "$debug"  "⤷ $(printf "%s " "$@")" >&2
  fi
}

# run commands with support for verbose output and dry-runs
run() {
  debug=$1; shift
  cmd_args=("$@")
  if [ "$opt_dryrun" = "true" ]; then
    printf "${C_BLUE}dry-run${C_NONE}\n%s\n" "⤷ $(printf "%s %s" "${cmd_args[*]}" "${arg_pass[*]}")" >&2
    return
  fi
  if [ "$opt_verbose" = "true" ]; then
    verbose "$debug" "${cmd_args[*]}"
  fi
  if [ ${#arg_pass[@]} -gt 0 ]; then
    verbose "passthrough" "${#arg_pass[@]}"
    "${cmd_args[@]}" "${arg_pass[*]}"
  else
    "${cmd_args[@]}"
  fi
  code=$?
  if [ $code = 0 ]; then
    return
  fi
  exit $code
}

# parse action
case "$1" in
  # handle help cases
  -h | --help | help ) exit_help;;
  '' ) exit_usage;;
  bootstrap ) opt_action=$1; shift
    set_help "$opt_action" "perform first time setup"
    set_usage "$opt_action"
    ;; 
  up ) opt_action=$1; shift
    set_help "$opt_action" "run the selected apps"
    set_usage "$opt_action"
    ;;
  down ) opt_action=$1; shift
    set_help "$opt_action" "shut down the selected apps"
    set_usage "$opt_action"
    ;;
  build ) opt_action=$1; shift
    set_help "$opt_action" "Build container images with trust for your Sandcastle private CA"
    set_usage "$opt_action" "-r|--required - build required container images not associated with an individual app"
    ;;
  * ) exit2 "invalid command" "$opt_action";;
esac

# parse remaining command-line options
set -- "$@" "${EOL:=$(printf '\1\3\3\7')}"  # end-of-list marker
opt_apps=()
arg_pass=()
while [ "$1" != "$EOL" ]; do
  opt="$1"; shift
  case "$opt" in

    # defined options - EDIT HERE!
    -a | --all      ) opt_all=true;;
    -h | --help     ) exit_help;;
    -r | --required ) opt_required=true;;
    -v | --verbose  ) opt_verbose=true;;
    -d | --dry-run  ) opt_dryrun=true;;

    # process special cases
    --) while [ "$1" != "$EOL" ]; do set -- "$@" "$1"; arg_pass+=("$1"); shift; done;;   # parse remaining as passthrough
    --[!=]*=*) set -- "${opt%%=*}" "${opt#*=}" "$@";;                  # "--opt=arg"  ->  "--opt" "arg"
    -[A-Za-z0-9] | -*[!A-Za-z0-9]*) exit2 "invalid option" "$opt";;    # anything invalid like '-*'
    -?*) other="${opt#-?}"; set -- "${opt%$other}" "-${other}" "$@";;  # "-abc"  ->  "-a" "-bc"
    *) opt_apps+=("$opt");;                                            # positional, rotate to the end
  esac
done; shift

if (command -v podman >/dev/null 2>&1) && (command -v podman-compose >/dev/null 2>&1);  then
  env_runtime="podman"
elif command -v docker >/dev/null 2>&1;  then
  env_runtime="docker"
else
  exit_runtime
fi

verbose "parsed options" """DIR = '$DIR'
  action = '$opt_action'
  arg_pass = ${arg_pass[*]}
  apps = ${opt_apps[*]}
  --all = $opt_all
  --required = $opt_required
  --verbose = $opt_verbose
  --dry-run = $opt_dryrun
  runtime = '$env_runtime'"""

# Zhu Li, do the thing!
case $opt_action in
  up )
    compose_files=("-f" "$DIR/docker-compose.yml")
    if [ "$opt_all" = "true" ]; then
      all_files=$(find "$DIR" -type f -name "*.compose.yml")
      for n in ${all_files[*]}; do compose_files+=("-f" "$n"); done 
    else
      for n in ${opt_apps[*]}; do compose_files+=("-f" "$n.compose.yml"); done
    fi
    cmd_args=("$env_runtime" "compose" "${compose_files[@]}" "up" "-d")
    run "$opt_action" "${cmd_args[@]}"
  ;;

  build )
    docker_files=()
    if [ "$opt_all" = "true" ]; then
      verbose "find all Dockerfiles"
      docker_files+=$(find "$DIR" -type f -name "*.Dockerfile")
    elif [ "$opt_required" = "true" ]; then
      verbose "find Dockerfiles" "--required"
      docker_files+=("$DIR/proxy.Dockerfile")
    fi
    if [ "$opt_all" != "true" ]; then
      for n in ${opt_apps[*]}; do
        verbose "find Dockerfiles" "$n"
        found=$(find "$DIR" -type f -name "$n*.Dockerfile")
        docker_files+=("$found")
        verbose "found" ${docker_files[*]}
      done
    fi
    
#    tags() is an array of "tuples" which don't exist in sh scripts as far as I know.
#    so, it's actually a regular array, but with paired elements.
#    Like ("x.Dockerfile" "tag/x:latest" "y.Dockerfile" "tag/y:latest")...
    tags=()
    for n in ${docker_files[*]}; do
      tags+=("$n" "localhost/sandcastles/$(basename ${n//.Dockerfile})");
    done
    
    i=0
    while [ "$i" -lt ${#tags[@]} ]; do 
      cmd_args=("$env_runtime" "build" "$DIR" "-f" "${tags[i]}" "-t" "${tags[i+1]}:latest")
      if [ $env_runtime = "podman" ]; then
        cmd_args+=("--format" "docker")
      fi
      run "$opt_action" "${cmd_args[@]}"
      i=$((i+2))
    done
  ;;
esac
